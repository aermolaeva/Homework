'number' + 3 + 3 буде 'number33'
// 'number' - це рядок, оператор '+' викликав конкатенацію

null + 3 буде 3
// значення null в JavaScript прирівнюється до 0, тож в результаті додавання 0 + 3 отримуємо 3

5 && "qwerty" буде "qwerty"
// оператор && повернув останнє правдиве значення, так як в цому випадку всі значення правдиві

+'40' + +'2' + "hillel" буде "42hillel"
/*
    унарний оператор '+' перетворив рядки +'40' і +'2' на числа 40 і 2, потім відбулося додавання (40 + 2 = 42), а далі
    відбулась конкатенація 42 + "hillel"
*/


'10' - 5 === 6 буде false
/*
    рядок '10' перетворився на число під час віднімання ('10' - 5 = 10 - 5), потім оператор строгої рівності перевірив
    значення 5 і 6, і так як ці значення нерівні, то маємо результат false
*/

true + false буде 1
// true і falsе прирівнюються до чисел true = 1, false = 0, далі відбувається операція додавання 1 + 0

'4px' - 3 буде NaN
/*
    віднімання не може бути виконане з рядком, тому JavaScript спробував перевести '4px' у число, а так як '4px' не є числом,
    то в результаті маємо Not a Number
*/

'4' - 3 буде 1
// теж саме, що в попередньому але тут рядок '4' перетворився на число 4, а 4 - 3 = 1

'6' + 3 ** 0 буде 61
// спочатку виконується піднесення до степеня (3 в нульвому степені буде 1), далі відбувається конкатенація '6' + 1

12 / '6' буде 2
// рядок '6' перетворюється на число під час ділення, 12 / 6 = 2

'10' + (5 === 6) буде '10false'
/*
    строга рівність повертає false, оскільки 5 не дорівнює 6, тож маємо '10' + false, далі оператор '+' виконує
    конкатенацію, тому false перетворюється на рядок ('10' + 'false')
*/

null == '' буде false
/*
    оператор == виконує нестроге порівняння, null порівнюється з пустим рядком '', а в JavaScript null не дорівнює нічому,
    крім самого себе
*/

3 ** (9 / 3) буде 27
// спочатку рахується те, що в дужках (9 / 3 = 3), далі відбувається піднесення до степеня (3 в степені 3 = 27)

!!'false' == !!'true' буде true
/*
    оператор !! перетворює значення в логічний тип, 'false' - це непорожній рядок, отже, !!'false' повертає true,
    'true' також непорожній, тому !!'true' також повертає true
*/

0 || '0' && 1 буде 1
/*
    спочатку обчислюємо '0' && 1, бо оператор && має вищий пріоритет, '0' є правдивим значенням, отже, результатом буде 1,
    далі оператор || повертає перше правдиве значення, тож, в результаті маємо 1
*/

(+null == false) < 1 буде false
/*
    +null перетворюється на число 0, тож маємо вираз 0 == false, так як false також є 0, то в результаті маємо true,
    таким чином, маємо true < 1, що є false, бо true прирівнюється до 1, а 1 не менше 1
*/

false && true || true буде true
/*
    оператор && виконується першим (false && true), що дає false, тепер маємо false || true,
    оператор || повертає перше правдиве значення, отже, результатом буде true
*/

false && (false || true) буде false
// спочатку рахуємо вираз у дужках (false || true), що дає true, маємо false && true, що дає false

(+null == false) < 1 ** 5 буде false
// +null дорівнює 0, раді зводимо 1 у ступінь 5, що дорівнює 1, (0 == false) вертає true і маємо true < 1, що є неправдою
